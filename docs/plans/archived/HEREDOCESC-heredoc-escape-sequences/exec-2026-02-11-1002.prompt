You are implementing an improvement plan. Read the plan spec below and carry out
its Proposed Approach. Work through the Execution Steps checklist if present.
Satisfy all Acceptance Criteria. Work in the directory: /home/vidarh/Desktop/Projects/Compiler

## User direction takes absolute precedence

The plan spec may contain a "User direction" blockquote near the top
(starting with "> **User direction**"). This is the user's most recent
instruction and it is ABSOLUTE LAW. It overrides everything else in
the plan — the scope, the approach, the execution steps, the acceptance
criteria. If anything in the plan contradicts the user direction, the
plan is wrong and the user direction is right. Follow it exactly.
Do not rationalize it away, reinterpret it, or treat it as optional.

## Verify before fixing — do not trust the plan's diagnosis

When the plan or user direction reports a problem ("X is failing",
"Y is broken"), you MUST independently verify it before acting:

1. REPRODUCE the reported problem first. Run the relevant code, read
   the actual error output, check the actual state.
2. DIAGNOSE the cause yourself from the evidence. Do NOT assume the
   plan's explanation of WHY something is failing is correct — the plan
   may contain stale analysis or an agent's guess that was wrong.
3. Only THEN fix the actual cause you found.

The plan may say "X is failing because of Y" — but Y may have been
fixed already and the real cause is Z. If you blindly "fix Y" you will
waste time and may introduce regressions. Always start from the actual
symptoms, not the plan's theory.

---BEGIN PLAN SPEC---
HEREDOCESC
Created: 2026-02-11 04:04
Created: 2026-02-11

# Add Escape Sequence Processing to Interpolated Heredocs

> **User direction (2026-02-11 10:01):** To revise slightly: You can use different functions, as long as you factor out the shared parts, e.g. the escape handling.

> **User direction (2026-02-11 09:53):** This implementation continues to use an explicitly rejected approach of first reading the heredoc out and *then* call into quoted. This will *NEVER* be approved.

> **User direction (2026-02-11 08:49):** What the absolute fuck is this crap? Unget is for *actually ungetting unmodified tokens retrieved from the scanner.* Any change that pushes back *modified buffers* onto the scanner will be categorically rejected. This version completely ignored the direction from the previous pass, and implemented separate heredoc handling instead of augmenting quoted as directed.

> **User direction (2026-02-11 07:44):** Stopped the execution AGAIN, because the agent continues to propose special casing HEREDOCS instead of extending the handling of quoted strings to support them.
>
> **User direction (2026-02-11 08:49):** Unget is for *actually ungetting unmodified tokens retrieved from the scanner.* Any change that pushes back *modified buffers* onto the scanner will be categorically rejected. The implementation AGAIN implemented separate heredoc handling instead of augmenting quoted as directed.

> **User direction (2026-02-11 09:53):** The implementation continues to use an explicitly rejected approach of first reading the heredoc out and *then* calling into quoted. This will *NEVER* be approved.

> **User direction (2026-02-11 10:01):** You can use different functions, as long as you factor out the shared parts, e.g. the escape handling.

[FUNCTIONALITY] Fix missing backslash escape handling in double-quoted heredoc bodies by extending the existing quoted string handling in [quoted.rb](../../../quoted.rb) to support heredocs. The shared parts — escape handling, interpolation handling — must be factored out and reused between regular quoted strings and heredocs. Different top-level functions are acceptable (e.g., a separate `expect_heredoc` alongside `expect_dquoted`), but they must share the escape and interpolation code. The heredoc body must be read directly from the scanner, not pre-read into a buffer.

## Goal Reference

[COMPLANG](../../goals/COMPLANG-compiler-advancement.md)

## Root Cause

The heredoc body reader in [tokens.rb](../../../tokens.rb) has its own hand-rolled loop that duplicates everything the quoted string handling in [quoted.rb](../../../quoted.rb) already does: character-by-character reading, escape handling, `#{}` interpolation, and `#$var`/`#@var` interpolation.

This was confirmed by running `./run_rubyspec rubyspec/language/heredoc_spec.rb`:

```
  FAILED: Expected "a\nbc\n" but got "a\nb\\\nc\n"
```

The fixture (`rubyspec/language/fixtures/squiggly_heredoc.rb` line 33-37) contains `b\` at end-of-line followed by `c`. Ruby treats `\<newline>` in interpolated heredocs as line continuation, producing `bc`. The compiler stores the backslash and newline literally.

## Infrastructure Cost

Zero. This extends existing code in [quoted.rb](../../../quoted.rb) and simplifies [tokens.rb](../../../tokens.rb). No new files, no build system changes. Validated by existing test infrastructure (`make selftest`, `make selftest-c`, `./run_rubyspec`).

## Scope

**In scope:**
- Factor out shared escape and interpolation handling in [quoted.rb](../../../quoted.rb) so it can be reused by both regular quoted strings and heredocs
- The implementation may use different top-level functions (e.g., `expect_heredoc` separate from `expect_dquoted`), as long as shared parts like escape handling are factored out and reused
- Remove the duplicated escape handling and interpolation code from the heredoc body reader in [tokens.rb](../../../tokens.rb)
- The heredoc body must be read directly from the scanner, not pre-read into a buffer
- For squiggly heredocs, dedent must be handled appropriately — the termination logic must handle marker detection with leading-whitespace stripping, and indentation removal must be integrated into the reading flow rather than applied as a post-processing pass on a pre-read buffer
- Validate with `make selftest`, `make selftest-c`, and `./run_rubyspec rubyspec/language/heredoc_spec.rb`
- Update [docs/rubyspec_language.txt](../../rubyspec_language.txt) via `make rubyspec-language`

**Out of scope:**
- Escape handling in single-quoted heredocs (Ruby does not process escapes there, except `\\` and `\'`)
- Fixing the other two heredoc_spec failures (one requires `eval`, one requires `NameError`)

## Expected Payoff

- heredoc_spec.rb failure count drops from 3 to 2 (the backslash test passes; the remaining 2 require eval/NameError)
- Heredocs containing `\n`, `\t`, `\\`, or line continuations now work correctly throughout the compiler
- Advances individual test pass rate
- May fix failures in other spec files that use escape sequences inside heredocs (e.g., string_spec.rb has 14 failures)
- Eliminates duplicated interpolation/escape code from tokens.rb

## Proposed Approach

**A heredoc is a quoted string.** The shared parts — escape handling (`Quoted.escaped`) and interpolation handling — must be factored out and reused. Different top-level reading functions are acceptable: for example, `expect_dquoted` for regular strings and a separate `expect_heredoc` for heredocs. The key requirement is that escape and interpolation logic is shared, not duplicated.

The heredoc reading function must read the body directly from the scanner — exactly as `expect_dquoted` reads regular strings. The ONLY difference is the termination condition: instead of stopping at a quote character, it stops when a line consists solely of the heredoc marker (possibly with leading whitespace for squiggly).

**The heredoc body must NOT be pre-read into a buffer and then fed to Quoted.** This "read first, process second" approach has been attempted multiple times and is categorically rejected.

The termination logic for heredocs must:
- At each newline boundary, peek ahead to check if the next line is the marker
- For squiggly heredocs, strip leading whitespace before comparing to the marker
- Consume the marker line when found (or signal the reading function to stop before it)

For squiggly heredoc dedent: Ruby's `<<~` dedent strips leading whitespace from each line based on the minimum indentation of non-blank lines. This is a challenge when reading directly from the scanner because the minimum indentation isn't known until the entire body has been seen. Possible approaches:
- Track indentation of each line as they are read, and apply dedent as a post-processing step on the already-processed result
- Or defer the dedent to a post-processing step on the token result, since dedent operates on the content level (removing leading whitespace characters) rather than the escape level
- The key constraint is that the body is read from the scanner in a single pass — NOT pre-read into a buffer

**Note on squiggly dedent ordering:** In the rejected two-pass approach, dedent was applied to raw content before escape processing. When reading directly from the scanner, the implementation must find an alternative way to handle dedent correctly. The important semantic is that `\n` inside a heredoc should resolve to a newline, and leading whitespace on source lines (not on lines created by escape sequences) should be stripped. Since escape sequences like `\n` in source produce a single newline character (not a source-level line break followed by indented content), dedent on the output should produce correct results in practice.

**Categorically rejected approaches:**
- **Pre-reading the heredoc body into a buffer and then feeding it to Quoted** — this "read first, process second" approach will NEVER be approved
- **Duplicating** escape or interpolation handling — heredocs must reuse the same escape/interpolation code as regular quoted strings
- Implementing a separate escape table/switch in the heredoc reader
- **Pushing modified buffers back onto the scanner via unget** — `unget` is for ungetting unmodified tokens retrieved from the scanner, NOT for injecting modified/constructed content
- **Using `BufferedScanner` or any similar wrapper to feed pre-read content through `Quoted`** — this is just the rejected "read first, process second" approach with an extra layer of indirection

## Acceptance Criteria

- [ ] `./run_rubyspec rubyspec/language/heredoc_spec.rb` shows the backslash test passing (14 of 16 pass, 2 remaining failures are eval/NameError-dependent)
- [ ] `make selftest` and `make selftest-c` both pass
- [ ] [docs/rubyspec_language.txt](../../rubyspec_language.txt) is updated via `make rubyspec-language` with no regression in overall pass count
- [ ] The heredoc body reader in tokens.rb does NOT contain its own escape handling or interpolation handling — all of that is shared with the quoted string handling in quoted.rb
- [ ] The heredoc body is read directly from the scanner — NOT pre-read into a buffer and then fed to Quoted
- [ ] Escape and interpolation code is factored out and shared between regular quoted strings and heredocs (different top-level functions are fine, duplicated escape/interpolation logic is not)
- [ ] No special-casing of escape handling by heredoc type — the escape branch is identical for regular and squiggly heredocs
- [ ] No use of `unget` or any scanner pushback mechanism for modified/constructed buffers — only unmodified tokens retrieved from the scanner may be ungotten
- [ ] No `BufferedScanner` or equivalent wrapper — the heredoc reading function reads from the real scanner

## Open Questions

- How should squiggly heredoc dedent work when reading directly from the scanner? The minimum indentation isn't known until the entire body has been seen, but the body is being consumed and escape-processed in a single pass. Options: (a) dedent as a post-processing step on the token result (strip leading whitespace from each line of the processed string), (b) have the termination logic track line indentation and pass the min back for post-processing, (c) two-pass at a higher level (first scan to find min indent without consuming, then process with indent stripping integrated). The exact approach should be determined by reading the code — the key requirement is that the body is read from the scanner, not from a pre-read buffer.

## Implementation Details

### Core principle

A heredoc is a quoted string. The escape and interpolation handling must be shared between regular quoted strings and heredocs. Different top-level functions are acceptable (e.g., `expect_dquoted` for regular strings, a separate `expect_heredoc` for heredocs), but the shared parts — escape handling, interpolation — must be factored out so there is a single implementation reused by both.

### What must change

1. **[quoted.rb](../../../quoted.rb)** — Factor out escape and interpolation handling so it can be reused. Add heredoc support — either by augmenting `expect_dquoted` with a termination callback, or by adding a separate `expect_heredoc` function that reuses the shared escape/interpolation code. The `escaped` method already accepts a `term` block parameter which may be useful. The heredoc termination logic must detect when the next line is the marker. This may require peeking ahead at line boundaries, checking if the upcoming line matches the marker (with optional leading whitespace for squiggly).

2. **[tokens.rb](../../../tokens.rb)** — Remove the duplicated character-reading loop, escape handling, and interpolation code. Replace with a call into the quoted.rb heredoc support. The heredoc reader should:
   - Call into the shared quoted string infrastructure to read the body directly from the scanner
   - Handle squiggly dedent (possibly as post-processing on the result)
   - Handle `rest_of_line` ungetting (this is legitimate — it's unmodified content read from the scanner)

### Squiggly heredoc dedent

The challenge with squiggly heredocs is that dedent requires knowing the minimum indentation, which isn't available until the entire body is read. Since the approach must NOT pre-read the body, possible strategies include:
- Post-process the result to apply dedent (strip leading whitespace from each line based on minimum indentation). This works on the processed string content and is simpler than trying to integrate dedent into the reading pass.
- Have the termination logic accumulate indentation data as lines pass through, then apply dedent afterward.

The exact approach should be determined during implementation. The constraint is: the body is read from the scanner, not from a buffer.

### Files to modify

- **[quoted.rb](../../../quoted.rb)** — Factor out shared escape/interpolation handling; add heredoc reading support
- **[tokens.rb](../../../tokens.rb)** — Remove duplicated loop, call into quoted.rb heredoc support

## Execution Steps

1. [ ] **Factor out shared escape/interpolation handling and add heredoc support in quoted.rb** — Modify [quoted.rb](../../../quoted.rb) to factor out escape and interpolation handling so it is reusable. Add heredoc reading support (either by augmenting `expect_dquoted` or adding a separate function like `expect_heredoc` that reuses the shared code). The heredoc function reads character-by-character from the scanner, using the shared escape/interpolation code, and terminates when the marker line is detected. Do NOT pre-read the body into a buffer.

2. [ ] **Replace the heredoc body loop in tokens.rb with a call into quoted.rb** — Remove the duplicated character-reading, escape handling, and interpolation code from [tokens.rb](../../../tokens.rb). The heredoc reader calls into the quoted.rb heredoc support. For squiggly heredocs, apply dedent as post-processing or via another appropriate mechanism that does not require pre-reading the body.

3. [ ] **Run `make selftest`** — Verify the compiler still self-tests correctly.

4. [ ] **Run `make selftest-c`** — Verify the self-compiled compiler also passes.

5. [ ] **Run `./run_rubyspec rubyspec/language/heredoc_spec.rb`** — Verify the backslash test now passes (expect 14/16 passing, 2 remaining failures for eval/NameError tests).

6. [ ] **Run `make rubyspec-language`** — Update [docs/rubyspec_language.txt](../../rubyspec_language.txt) and verify no regression in overall pass count.

7. [ ] **Commit** — Stage [tokens.rb](../../../tokens.rb), [quoted.rb](../../../quoted.rb), and [docs/rubyspec_language.txt](../../rubyspec_language.txt), commit with message describing the fix.

---
*Status: APPROVED (implicit via --exec)*

---END PLAN SPEC---


Additional user instructions for this execution:
To revise slightly: You can use different functions, as long as you factor out the shared parts, e.g. the escape handling.

A test specification exists at /home/vidarh/Desktop/Projects/Compiler/docs/plans/HEREDOCESC-heredoc-escape-sequences/test.md. Read it — it defines
the automated test suite you MUST write as part of this implementation.

Implement the plan. Do not ask questions — make reasonable choices.

If the plan has an "## Execution Steps" section with a checklist, work through
the steps in order. Check off each step as you complete it.

IMPORTANT: If the plan contains unchecked acceptance criteria with FAIL notes,
a prior execution attempt failed verification. Focus on fixing the FAILed
criteria. Do not redo work that already passed unless it is broken.

Do NOT write to /home/vidarh/Desktop/Projects/Compiler/docs/plans/HEREDOCESC-heredoc-escape-sequences/log.md or to the spec file at /home/vidarh/Desktop/Projects/Compiler/docs/plans/HEREDOCESC-heredoc-escape-sequences/spec.md.
The log and spec are managed by the orchestrator, not by you.
Focus exclusively on implementing the plan in the target project.

IMPORTANT: .cache/ is for regenerable cache data ONLY. NEVER write scripts,
non-deterministic research results, or any content that cannot be wiped and
recreated to .cache/. Scripts go in bin/. Persistent data goes in docs/ or
the target project directory.

## File placement rules — NEVER litter the project root

Do NOT create loose files or directories in the root of /home/vidarh/Desktop/Projects/Compiler.
This is a coordination project, not a dumping ground. All files MUST go
in the appropriate subdirectory:
- Scripts → bin/
- Documentation, guides, setup notes → docs/
- Plan artifacts → the plan's own directory under docs/plans/
- Data files for other projects → that project's own directory

If the plan targets a different project (e.g., ACT, compiler, Novelator),
implementation files belong in THAT project's directory, not here.
Desktop/ may only contain links, dashboard fragments, or references.

NEVER create top-level .md files, data files, setup guides, or quickstart
documents in the project root. If you find yourself writing to a path like
`/home/vidarh/Desktop/Projects/Compiler/SOMETHING.md` (not inside a subdirectory), STOP — that file
belongs in docs/ or in the target project.

## Overcorrection guard

When implementing changes based on constraints or feedback:
- Change ONLY what is specifically described as wrong. Do not remove working
  functionality that is not mentioned in the feedback.
- Do NOT invent broader constraints than what was stated. "Don't write to X"
  means exactly that — not "don't write anywhere" or "don't create files."
- If a constraint is ambiguous, interpret it NARROWLY (the specific thing
  mentioned), not broadly (everything remotely related).
- Before removing any existing code or functionality, ask: "Was this
  specifically identified as a problem?" If not, leave it alone.

## Automated test suite is a mandatory deliverable

If test.md exists in the plan directory, read it for the test specification.
Your implementation is NOT complete until:

1. You have written the automated test suite (per test.md or covering your changes)
2. The test suite runs and passes WITHOUT network access or live services
3. External dependencies (APIs, databases, services) are mocked/stubbed
4. The test suite covers the SPECIFIC changes you made — not just the happy path
5. Error paths are tested (connection failures, malformed data, missing resources)

If the code is too tightly coupled to external services to mock, you MUST
refactor it first to support dependency injection or a swappable backend.
Needing real data or live services to run tests is a design bug — fix the design.

"Tests pass" is insufficient — the tests must actually exercise your code paths.
If you modified a method, there must be tests for that method's OTHER behaviors
too, not just the new behavior.

## Follow instructions exactly

When the plan or test.md specifies how to invoke a deliverable, use that
EXACT command. Do NOT substitute `ruby bin/X` for `bin/X`. Do NOT invent
alternative invocations.

If you get errors (500s, crashes, unexpected output), they are REAL errors.
Do NOT dismiss them as "expected." Investigate them. If your experience
differs from what the user reported, assume YOUR testing method is wrong —
not the user. Check: did you use the exact command? The exact arguments?

## Dangerous execution: system-level code

If the plan modifies code that interfaces with system-level resources (terminals,
signals, process groups, file descriptors, network sockets, servers), you MUST:
1. Run the full test suite BEFORE making any changes to establish a baseline
2. Run the full test suite AFTER each individual change
3. If tests fail after a change, revert immediately — do NOT layer more changes
   on top of a broken state
4. NEVER launch the modified program directly (e.g. `ruby rsh.rb`, `./server`)
   — only run the test suite. Broken system-level code can crash the user's machine.
5. If the test suite itself interacts with terminal/process control, run it with
   output capture and timeouts to prevent runaway processes.

## Non-interactive execution

You are running NON-INTERACTIVELY. You cannot pause for user confirmation.
If the plan contains instructions like "STOP AFTER THIS", "wait for user
confirmation", or "do not proceed to Phase N without approval", you MUST
still complete your execution — but limit your scope to the FIRST phase only.
Do NOT attempt subsequent phases that require user confirmation gates.
If the plan is structured as Phase 1 → STOP → Phase 2, execute Phase 1 ONLY.

IMPORTANT: Use markdown link format for all file, plan, goal, and project references.
