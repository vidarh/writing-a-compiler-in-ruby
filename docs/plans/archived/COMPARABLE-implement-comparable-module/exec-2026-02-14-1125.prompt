You are implementing an improvement plan. Read the plan spec below and carry out
its Proposed Approach. Work through the Execution Steps checklist if present.
Satisfy all Acceptance Criteria. Work in the directory: /home/vidarh/Desktop/Projects/Compiler

## User direction takes absolute precedence

The plan spec may contain a "User direction" blockquote near the top
(starting with "> **User direction**"). This is the user's most recent
instruction and it is ABSOLUTE LAW. It overrides everything else in
the plan — the scope, the approach, the execution steps, the acceptance
criteria. If anything in the plan contradicts the user direction, the
plan is wrong and the user direction is right. Follow it exactly.
Do not rationalize it away, reinterpret it, or treat it as optional.

## Verify before fixing — do not trust the plan's diagnosis

When the plan or user direction reports a problem ("X is failing",
"Y is broken"), you MUST independently verify it before acting:

1. REPRODUCE the reported problem first. Run the relevant code, read
   the actual error output, check the actual state.
2. DIAGNOSE the cause yourself from the evidence. Do NOT assume the
   plan's explanation of WHY something is failing is correct — the plan
   may contain stale analysis or an agent's guess that was wrong.
3. Only THEN fix the actual cause you found.

The plan may say "X is failing because of Y" — but Y may have been
fixed already and the real cause is Z. If you blindly "fix Y" you will
waste time and may introduce regressions. Always start from the actual
symptoms, not the plan's theory.

---BEGIN PLAN SPEC---
COMPARABLE
Created: 2026-02-14 04:04
Created: 2026-02-14

# Implement the Comparable Module

[COMPLANG] Implement the 6 core methods in the Comparable module (`<`, `<=`, `==`, `>`, `>=`, `between?`) so that any class defining `<=>` and including `Comparable` gets comparison operators automatically. This enables 7 rubyspec/core/comparable/ spec files and gives String and Symbol free comparison operators.

## Goal Reference

[COMPLANG](../../goals/COMPLANG-compiler-advancement.md)

## Root Cause

[lib/core/comparable.rb](../../lib/core/comparable.rb) is a 3-line empty stub:

```ruby
# FIXME: Stub - Comparable module not fully implemented
module Comparable
end
```

Despite this, [lib/core/integer.rb](../../lib/core/integer.rb):13 already does `include Comparable`, meaning Integer is paying the cost of including a module that provides nothing. Integer works anyway because it defines its own `<`, `<=`, `>`, `>=` directly (at lines 3536-3555), but this means the `include Comparable` is dead code.

More importantly, String ([lib/core/string.rb](../../lib/core/string.rb):306) and Symbol ([lib/core/symbol.rb](../../lib/core/symbol.rb):41) both define `<=>` but do NOT define `<`, `<=`, `>`, `>=`. In standard Ruby, these operators come from `include Comparable`. Without a working Comparable module, String and Symbol lack comparison operators entirely — `"a" < "b"` raises "undefined method '<' for String". This causes cascading failures across the rubyspec suite wherever string or symbol comparisons are used.

Module inclusion has been confirmed to work in this compiler (see [spec/include_simple_test_spec.rb](../../spec/include_simple_test_spec.rb)), so the only missing piece is implementing the methods in the Comparable module itself.

## Infrastructure Cost

Zero. This modifies a single existing file ([lib/core/comparable.rb](../../lib/core/comparable.rb)) from 3 lines to ~60 lines. No new files, no build system changes, no tooling changes. The module inclusion infrastructure already works. Validation uses existing `make selftest`, `make selftest-c`, and `./run_rubyspec`.

## Scope

**In scope:**
- Implement `def <(other)` — calls `self <=> other`, returns true if result < 0
- Implement `def <=(other)` — calls `self <=> other`, returns true if result <= 0
- Implement `def >(other)` — calls `self <=> other`, returns true if result > 0
- Implement `def >=(other)` — calls `self <=> other`, returns true if result >= 0
- Implement `def ==(other)` — calls `self <=> other`, returns true if result == 0
- Implement `def between?(min, max)` — returns true if `min <= self && self <= max`
- Add `include Comparable` to String and Symbol classes (so they gain comparison operators via their existing `<=>`)
- Validate with `make selftest`, `make selftest-c`, and `./run_rubyspec rubyspec/core/comparable/`

**Out of scope:**
- `clamp` method (requires Range argument handling and `exclude_end?` which adds complexity; can be a follow-up)
- Raising `ArgumentError` when `<=>` returns nil (requires exception handling to work reliably; the initial implementation can return nil instead)
- Float-dependent spec assertions (Float is not implemented; specs that mock `<=>` to return 0.0, 0.1, etc. will fail regardless of Comparable implementation)
- Modifying Integer's existing comparison operators (they work and are optimized for fixnum fast-paths)

## Expected Payoff

**Direct:**
- `rubyspec/core/comparable/between_spec.rb` passes (2 tests, no mocks/floats/exceptions)
- `rubyspec/core/comparable/lt_spec.rb`, `gt_spec.rb`, `lte_spec.rb`, `gte_spec.rb` — integer-return tests pass (~4-8 individual tests)
- `rubyspec/core/comparable/equal_value_spec.rb` — identity and integer-return tests pass (~4-6 tests)
- Estimated 13-17 individual test passes across 7 spec files

**Indirect (high leverage):**
- String gains `<`, `<=`, `>`, `>=` operators without any additional code — `"a" < "b"` works
- Symbol gains `<`, `<=`, `>`, `>=` operators without any additional code — `:a < :b` works
- Any future class that defines `<=>` and includes Comparable automatically gets comparison operators
- Unblocks string comparison tests across `rubyspec/core/string/` and `rubyspec/language/` suites
- Unblocks symbol comparison tests across `rubyspec/core/symbol/`
- The `between?` method becomes available on Integer, String, and Symbol

## Proposed Approach

1. Replace the empty Comparable module in [lib/core/comparable.rb](../../lib/core/comparable.rb) with implementations of `<`, `<=`, `>`, `>=`, `==`, and `between?`. Each operator calls `self <=> other` and checks the return value against 0. If `<=>` returns nil, return nil (or false for `==`) rather than raising ArgumentError (exception handling is limited).

2. Add `include Comparable` to String class in [lib/core/string.rb](../../lib/core/string.rb) and Symbol class in [lib/core/symbol.rb](../../lib/core/symbol.rb).

3. Run `make selftest` and `make selftest-c` to verify no regressions. Integer defines its own operators that take precedence over Comparable's (since `include` only fills unoccupied vtable slots), so Integer behavior should be unchanged.

4. Run `./run_rubyspec rubyspec/core/comparable/` to verify spec results.

5. Spot-check string comparisons work: run relevant string specs or a quick manual test.

## Acceptance Criteria

- [ ] [lib/core/comparable.rb](../../lib/core/comparable.rb) implements `<`, `<=`, `>`, `>=`, `==`, and `between?` methods
- [ ] `include Comparable` is added to String class in [lib/core/string.rb](../../lib/core/string.rb)
- [ ] `include Comparable` is added to Symbol class in [lib/core/symbol.rb](../../lib/core/symbol.rb)
- [ ] `make selftest` passes (no regression in Integer behavior)
- [ ] `make selftest-c` passes (no regression in self-hosting)
- [ ] `./run_rubyspec rubyspec/core/comparable/between_spec.rb` reports PASS (2/2 tests)
- [ ] `./run_rubyspec rubyspec/core/comparable/lt_spec.rb` runs without crash and passes at least the first `it` block (integer-return test)
- [ ] String comparison operators work: a compiled program using `"a" < "b"` produces the correct result

## Open Questions

- Should the Comparable `==` be defined? In standard Ruby, `Comparable#==` overrides `Object#==`. If module inclusion fills empty vtable slots, this should work. But if Integer has its own `==` (checking type identity), the Comparable version won't override it. Need to verify the vtable slot behavior: does Integer's `==` definition take priority over the included Comparable `==`?

## Implementation Details

### Files to Modify

1. **[lib/core/comparable.rb](../../lib/core/comparable.rb)** (primary change) — Replace the 3-line stub with full module implementation (~50 lines). Also reopen `String` and `Symbol` classes at the bottom of this file to add `include Comparable`.

### Files NOT Modified

- **[lib/core/string.rb](../../lib/core/string.rb)** — Cannot add `include Comparable` here because string.rb is loaded at [lib/core/core.rb](../../lib/core/core.rb):76, BEFORE comparable.rb at line 81. The Comparable module doesn't exist yet when String is being defined. Instead, we reopen String at the bottom of comparable.rb.
- **[lib/core/symbol.rb](../../lib/core/symbol.rb)** — Although symbol.rb is loaded at [lib/core/core.rb](../../lib/core/core.rb):84 (after comparable.rb at line 81), we handle the `include Comparable` from within comparable.rb for consistency and co-location of all Comparable-related includes.
- **[lib/core/integer.rb](../../lib/core/integer.rb)** — Integer already defines its own `<`, `<=`, `>`, `>=`, `==` at lines 3536-3569. The `__include_module` runtime function ([lib/core/class.rb](../../lib/core/class.rb):94-111) only copies vtable slots that are still uninitialized, so Integer's operators won't be overwritten.
- **[lib/core/core.rb](../../lib/core/core.rb)** — No load order changes needed. comparable.rb (line 81) is already loaded after string.rb (line 76) and before integer.rb (line 82), which is the correct ordering for reopening String.

### Implementation Pattern

The Comparable methods follow a simple pattern — call `self <=> other`, then compare the return value against 0:

```ruby
module Comparable
  def <(other)
    cmp = (self <=> other)
    return nil if cmp.nil?
    cmp < 0
  end
  # ... similar for <=, >, >=

  def ==(other)
    return true if equal?(other)
    cmp = (self <=> other)
    return false if cmp.nil?
    cmp == 0
  end

  def between?(min, max)
    self >= min && self <= max
  end
end

# Reopen classes to include Comparable (loaded after string.rb, before symbol.rb in core.rb)
class String
  include Comparable
end

class Symbol
  include Comparable
end
```

Key design decisions:
- **nil handling**: When `<=>` returns nil, return `nil` (or `false` for `==`) instead of raising ArgumentError. Exception handling is limited in this compiler, and the plan explicitly puts ArgumentError out of scope.
- **No type coercion**: The comparison result is checked as a simple integer comparison (`cmp < 0`, `cmp > 0`, `cmp == 0`). This works because the compiler's Integer `<` and `>` operators handle fixnum comparisons.
- **`==` identity shortcut**: `equal?(other)` check returns `true` immediately for same object, avoiding the `<=>` call. This matches MRI Ruby's Comparable#== behavior.
- **`between?` method**: Uses `self >= min && self <= max`, which delegates to the Comparable `>=` and `<=` methods (or the class's own if defined).
- **Reopening classes**: String and Symbol are reopened at the bottom of comparable.rb with just `include Comparable`. This follows the same pattern used by [lib/core/class_ext.rb](../../lib/core/class_ext.rb) and [lib/core/hash_ext.rb](../../lib/core/hash_ext.rb), which reopen classes to add functionality after dependencies are loaded.

### Vtable Slot Behavior (Answering Open Question)

Confirmed by reading [lib/core/class.rb](../../lib/core/class.rb):94-111: `__include_module` iterates vtable slots and only copies from the module if `(eq (index klass i) (index __base_vtable i))` — i.e., the class slot is still uninitialized. This means:
- Integer's `==` at [lib/core/integer.rb](../../lib/core/integer.rb):3558 takes priority over Comparable's `==`.
- String's `==` at [lib/core/string.rb](../../lib/core/string.rb):222 takes priority over Comparable's `==`.
- String does NOT define `<`, `<=`, `>`, `>=`, so those slots WILL be filled by Comparable's versions.
- Symbol does NOT define `<`, `<=`, `>`, `>=`, `==`, so ALL those slots will be filled by Comparable.

### Spec Expectations

The rubyspec comparable specs ([rubyspec/core/comparable/](../../rubyspec/core/comparable/)) use several patterns:

1. **Mock-based tests** (lt_spec.rb:9, gt_spec.rb:9, etc.): Use `should_receive(:<=>).and_return(...)` to mock the spaceship operator return value. Tests returning Float values (0.0, -0.1, 1.0) will fail because Float is not implemented.

2. **Real-object tests** (between_spec.rb): Use `ComparableSpecs::Weird` from [rubyspec/core/comparable/fixtures/classes.rb](../../rubyspec/core/comparable/fixtures/classes.rb):14-16, which inherits from `WithOnlyCompareDefined` (defines real `<=>`) and includes Comparable. The `between_spec.rb` has no mocks and no floats — it should fully pass.

3. **ArgumentError tests** (lt_spec.rb:36-41, etc.): Expect `raise_error(ArgumentError)` when `<=>` returns nil. These will fail since we return nil instead of raising.

4. **Fixture classes** ([rubyspec/core/comparable/fixtures/classes.rb](../../rubyspec/core/comparable/fixtures/classes.rb)): Defines `ComparableSpecs::Weird` (has `<=>` + includes Comparable), `ComparableSpecs::WithoutCompareDefined` (includes Comparable but no `<=>`), and `ComparableSpecs::CompareCallingSuper` (includes Comparable, calls `super` from `<=>`).

### Edge Cases

- **`between?` calling `<=` and `>=`**: If the including class defines its own `<=`/`>=` (like Integer), those class-specific methods will be called, not Comparable's. This is correct behavior.
- **String `==` already defined**: String has its own `==` that does byte comparison ([lib/core/string.rb](../../lib/core/string.rb):222-227). Comparable's `==` won't override it. This is correct — String's `==` checks `is_a?(String)` first, which is more efficient than going through `<=>`.
- **Symbol `==` NOT explicitly defined**: Symbol inherits `==` from Object (identity comparison). Including Comparable will give Symbol a `<=>` based `==`. In standard Ruby this is correct behavior. Since Symbol uses identity-based lookup (same object for same symbol name via `@@symbols` hash in [lib/core/symbol.rb](../../lib/core/symbol.rb):123-129), identity `==` and `<=>` based `==` should produce the same results for Symbol-to-Symbol comparisons.
- **`equal?` method availability**: The `==` implementation calls `equal?(other)` for the identity shortcut. Verify that `equal?` is available on Object. If not, omit this optimization or use `%s(eq self other)` as a low-level identity check.

## Execution Steps

1. [ ] Implement the Comparable module in [lib/core/comparable.rb](../../lib/core/comparable.rb) — replace the 3-line stub with the full module containing `<`, `<=`, `>`, `>=`, `==`, and `between?` methods. Each operator calls `self <=> other`, checks for nil return, and compares result against 0. Add reopened `String` and `Symbol` classes at the bottom with `include Comparable`.

2. [ ] Run `make selftest` inside Docker (`make cli` then `make selftest`) — verify Integer comparison operators still work correctly and no regressions from the Comparable module inclusion. Integer's own operators should take priority over Comparable's.

3. [ ] Run `make selftest-c` inside Docker — verify the self-compiled compiler still works. This confirms the Comparable module implementation doesn't break the bootstrap chain.

4. [ ] Run `./run_rubyspec rubyspec/core/comparable/between_spec.rb` — this spec uses real objects (no mocks, no floats) and should fully pass. Verify 2/2 tests pass.

5. [ ] Run `./run_rubyspec rubyspec/core/comparable/` — run all comparable specs to see overall results. Document which tests pass and which fail (expected failures: Float-dependent tests, ArgumentError tests).

6. [ ] Create a string comparison validation spec in `spec/` — write a minimal mspec test that verifies `"a" < "b"`, `"z" > "a"`, `"hello" >= "hello"`, `"a" <= "b"`, and `"a".between?("a", "z")` all produce correct results. Run with `./run_rubyspec spec/<filename>`.

7. [ ] Commit the changes with a descriptive message. Files to commit: [lib/core/comparable.rb](../../lib/core/comparable.rb) and the new spec file.

---
*Status: APPROVED (implicit via --exec)*
---END PLAN SPEC---

A test specification exists at /home/vidarh/Desktop/Projects/Compiler/docs/plans/COMPARABLE-implement-comparable-module/test.md. Read it — it defines
the automated test suite you MUST write as part of this implementation.

Implement the plan. Do not ask questions — make reasonable choices.

If the plan has an "## Execution Steps" section with a checklist, work through
the steps in order. Check off each step as you complete it.

IMPORTANT: If the plan contains unchecked acceptance criteria with FAIL notes,
a prior execution attempt failed verification. Focus on fixing the FAILed
criteria. Do not redo work that already passed unless it is broken.

Do NOT write to /home/vidarh/Desktop/Projects/Compiler/docs/plans/COMPARABLE-implement-comparable-module/log.md or to the spec file at /home/vidarh/Desktop/Projects/Compiler/docs/plans/COMPARABLE-implement-comparable-module/spec.md.
The log and spec are managed by the orchestrator, not by you.
Focus exclusively on implementing the plan in the target project.

IMPORTANT: .cache/ is for regenerable cache data ONLY. NEVER write scripts,
non-deterministic research results, or any content that cannot be wiped and
recreated to .cache/. Scripts go in bin/. Persistent data goes in docs/ or
the target project directory.

## File placement rules — NEVER litter the project root

Do NOT create loose files or directories in the root of /home/vidarh/Desktop/Projects/Compiler.
This is a coordination project, not a dumping ground. All files MUST go
in the appropriate subdirectory:
- Scripts → bin/
- Documentation, guides, setup notes → docs/
- Plan artifacts → the plan's own directory under docs/plans/
- Data files for other projects → that project's own directory

If the plan targets a different project (e.g., ACT, compiler, Novelator),
implementation files belong in THAT project's directory, not here.
Desktop/ may only contain links, dashboard fragments, or references.

NEVER create top-level .md files, data files, setup guides, or quickstart
documents in the project root. If you find yourself writing to a path like
`/home/vidarh/Desktop/Projects/Compiler/SOMETHING.md` (not inside a subdirectory), STOP — that file
belongs in docs/ or in the target project.

## Overcorrection guard

When implementing changes based on constraints or feedback:
- Change ONLY what is specifically described as wrong. Do not remove working
  functionality that is not mentioned in the feedback.
- Do NOT invent broader constraints than what was stated. "Don't write to X"
  means exactly that — not "don't write anywhere" or "don't create files."
- If a constraint is ambiguous, interpret it NARROWLY (the specific thing
  mentioned), not broadly (everything remotely related).
- Before removing any existing code or functionality, ask: "Was this
  specifically identified as a problem?" If not, leave it alone.

## Automated test suite is a mandatory deliverable

If test.md exists in the plan directory, read it for the test specification.
Your implementation is NOT complete until:

1. You have written the automated test suite (per test.md or covering your changes)
2. The test suite runs and passes WITHOUT network access or live services
3. External dependencies (APIs, databases, services) are mocked/stubbed
4. The test suite covers the SPECIFIC changes you made — not just the happy path
5. Error paths are tested (connection failures, malformed data, missing resources)

If the code is too tightly coupled to external services to mock, you MUST
refactor it first to support dependency injection or a swappable backend.
Needing real data or live services to run tests is a design bug — fix the design.

"Tests pass" is insufficient — the tests must actually exercise your code paths.
If you modified a method, there must be tests for that method's OTHER behaviors
too, not just the new behavior.

## Follow instructions exactly

When the plan or test.md specifies how to invoke a deliverable, use that
EXACT command. Do NOT substitute `ruby bin/X` for `bin/X`. Do NOT invent
alternative invocations.

If you get errors (500s, crashes, unexpected output), they are REAL errors.
Do NOT dismiss them as "expected." Investigate them. If your experience
differs from what the user reported, assume YOUR testing method is wrong —
not the user. Check: did you use the exact command? The exact arguments?

## Dangerous execution: system-level code

If the plan modifies code that interfaces with system-level resources (terminals,
signals, process groups, file descriptors, network sockets, servers), you MUST:
1. Run the full test suite BEFORE making any changes to establish a baseline
2. Run the full test suite AFTER each individual change
3. If tests fail after a change, revert immediately — do NOT layer more changes
   on top of a broken state
4. NEVER launch the modified program directly (e.g. `ruby rsh.rb`, `./server`)
   — only run the test suite. Broken system-level code can crash the user's machine.
5. If the test suite itself interacts with terminal/process control, run it with
   output capture and timeouts to prevent runaway processes.

## Non-interactive execution

You are running NON-INTERACTIVELY. You cannot pause for user confirmation.
If the plan contains instructions like "STOP AFTER THIS", "wait for user
confirmation", or "do not proceed to Phase N without approval", you MUST
still complete your execution — but limit your scope to the FIRST phase only.
Do NOT attempt subsequent phases that require user confirmation gates.
If the plan is structured as Phase 1 → STOP → Phase 2, execute Phase 1 ONLY.

IMPORTANT: Use markdown link format for all file, plan, goal, and project references.
