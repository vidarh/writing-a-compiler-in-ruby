# Compiler Development Session - 2025-11-14

## Overview

This session focused on fixing the `begin` keyword to work as a prefix operator in the shunting yard parser, enabling method chaining on begin blocks similar to `if`, `unless`, `while`, and `until`.

## Problem Statement

The `ensure_spec.rb` rubyspec was failing with "Missing value in expression" when trying to chain methods on `begin...end` blocks:

```ruby
begin
  :test
ensure
  :ensure
end.should == :begin  # Failed with parse error
```

The issue was that `begin` was being parsed directly in `parse_defexp` rather than going through the shunting yard parser, preventing method chaining support.

## Solution

Implemented `begin` as a prefix operator that's intercepted by the shunting yard parser, following the same pattern used for `if`/`unless`/`while`/`until`.

### Changes Made

1. **operators.rb** (line 88):
   - Added `"begin"` as an operator with symbol `:begin_stmt` and priority 2
   - Pattern: `"begin" => Oper.new(2, :begin_stmt, :infix, 2, 2, :right, 1)`

2. **shunting.rb** (lines 122-125):
   - Added handler for `:begin_stmt` in prefix position
   - Calls `@parser.parse_begin_body` and pushes result with `@out.value()`
   - Returns `:prefix` to indicate successful prefix parsing

3. **shunting.rb** (line 250):
   - Removed `begin` from `[:for, :lambda, :def]` special keyword list
   - Updated comment to note "unless, until, and begin are now handled as operators"

4. **parser.rb** (lines 296-306):
   - Created new `parse_begin_body` method that doesn't consume the `begin` keyword
   - Modified `parse_begin` to consume `begin` keyword then call `parse_begin_body`
   - This mirrors the `parse_if` / `parse_if_body` pattern

5. **parser.rb** (line 462):
   - Removed `parse_begin ||` from the `parse_defexp` call chain
   - `begin` is now only handled via the shunting yard operator mechanism

6. **compiler.rb** (line 318):
   - Fixed `compile_rescue` to accept optional 4th parameter (`else_body`)
   - Was causing "wrong number of arguments (given 4, expected 3)" errors
   - Comment notes that else_body is handled in `compile_block`, not here

## Technical Details

### Why This Works

The key insight is that when `begin` appears at the start of an expression:

1. The scanner sees `begin` as a token
2. The shunting yard recognizes it as an operator (`:begin_stmt`)
3. Since `opstate == :prefix`, it calls the handler at shunting.rb:122
4. Handler calls `parse_begin_body` (which parses the body without re-consuming `begin`)
5. Result is pushed onto the value stack via `@out.value(result)`
6. Control returns to shunting yard with `:prefix` state
7. Next token (e.g., `.inspect`) is parsed as a method call on the value
8. Method chaining works automatically!

This is identical to how `if`, `unless`, `while`, and `until` work.

### Comparison: Before vs After

**Before (parse_defexp approach):**
```
parse_defexp → parse_begin → returns result
→ caller doesn't know to check for method chaining
→ `.method` seen as separate statement
→ FAIL
```

**After (operator approach):**
```
shunting yard sees 'begin' → calls parse_begin_body → pushes to value stack
→ shunting yard continues parsing
→ sees '.' → recognizes method call operator
→ builds [:callm, begin_result, :method, []]
→ SUCCESS
```

## Test Results

### Core Tests
- ✅ **selftest**: 0 failures (all passing)
- ✅ **selftest-c**: 0 failures (self-compilation works)

### RubySpec Results
- ✅ **and_spec.rb**: Still passes (10/10 tests) - no regression
- ✅ **unless_spec.rb**: **NOW PASSES** (6/6 tests) - was compilation failure before!

### Example Code That Now Works
```ruby
# Standalone begin with method chaining
begin
  :test
ensure
  :ensure
end.inspect
# ✓ Compiles and runs successfully

# Assignment with method chaining
x = begin
  :test
ensure
  :ensure
end.inspect
# ✓ Compiles and runs successfully
```

## Bonus Discovery

The `begin` operator fix had an unexpected positive side effect: **unless_spec.rb now passes completely** (6/6 tests)!

This was previously listed as a compilation failure. The fix to how `begin` is handled appears to have resolved an issue with how `unless` blocks were being parsed or compiled.

## Known Limitations

1. **ensure_spec.rb** still has issues:
   - Now fails with "negative argument" error in emitter.rb:614
   - This is a different bug: function names longer than 70 characters cause negative multiplication
   - Not related to the `begin` operator fix

2. **while_spec.rb** and **until_spec.rb** still fail:
   - These have the known "break if condition" bug (KNOWN_ISSUES #2)
   - Example: `a ||= (break if c)` consumes wrong tokens
   - Not related to this fix

## Files Modified

- `operators.rb`: Added begin operator definition
- `shunting.rb`: Added begin handler, removed from special keyword list
- `parser.rb`: Created parse_begin_body, removed parse_begin from parse_defexp
- `compiler.rb`: Fixed compile_rescue parameter count
- `docs/TODO.md`: Documented the fix and results

## Commits

- `1bdb613`: Make begin a prefix operator to enable method chaining
- `9042666`: Update TODO.md with begin operator fix (2025-11-14)
- `c5a3f03`: Document unless_spec.rb now passes with begin operator fix

## Conclusion

Successfully implemented `begin` as a prefix operator, bringing it in line with `if`, `unless`, `while`, and `until`. This enables proper method chaining on begin blocks and serves as a clean example of how the shunting yard parser handles control flow keywords.

The fix demonstrates the power of the operator-based approach: by treating control flow keywords as operators that are intercepted during expression parsing, method chaining "just works" without any special-case code in each parser method.

**Impact**:
- 1 new passing spec (unless_spec.rb: 6 tests)
- 0 regressions
- Cleaner architecture (begin now follows same pattern as if/while/until)
