./compile test/selftest.rb -I. -g
*** Compiling with arguments: 'test/selftest.rb -I. -g' into out/selftest
ruby -I. ./driver.rb test/selftest.rb -I. -g 2>&1 >out/selftest.s
gcc -Wall -g -c -m32 -o out/tgc.o tgc.c
+++ [32mCompiled tgc[37m
gcc -g -m32 -o out/selftest out/selftest.s out/tgc.o
+++ [32mCompiled to out/selftest[37m
== Compiled:
out/selftest
[32mPASS[37m: 40 % 10 == 0 [expected/got "0"]
[32mPASS[37m: 42 / 7 == 6 [expected/got 6]
[32mPASS[37m: 4096.to_s(10) => '4096' [expected/got "4096"]
[32mPASS[37m: 4096.inspect => '4096' [expected/got "4096"]
[32mPASS[37m: Converting -4 to a string [expected/got "-4"]
[32mPASS[37m: 0 - 4 [expected/got -4]
[32mPASS[37m: Converting -4 from a string to Fixnum and back [expected/got "-4"]
[32mPASS[37m: Converting -4 to a string [expected/got "-4"]
[32mPASS[37m: 4 <=> 3 should return 1 [expected/got 1]
[32mPASS[37m: Same symbol should match with #== [expected/got true]
[32mPASS[37m: Same symbol should match with #=== [expected/got true]
[32mPASS[37m: Same symbol should match with #eql? [expected/got true]
[32mPASS[37m: :foo != :foo => false [expected/got false]
[32mPASS[37m: :foo != :bar => true [expected/got true]
[32mPASS[37m: A Symbol should respond to #to_sym [expected/got true]
[32mPASS[37m: #length on empty array [expected/got 0]
[32mPASS[37m: #length on 3-element array [expected/got 3]
[32mPASS[37m: [42,43,44].delete_at(1) should return 43 [expected/got 43]
[32mPASS[37m: [42, 44].inspect should return [42, 44] [expected/got "[42, 44]"]
[32mPASS[37m: #length after [42,43,44].delete_at(1) [expected/got 2]
[32mPASS[37m: [42,44].delete_at(0) should return 42 [expected/got 42]
[32mPASS[37m: #length after [42,44].delete_at(0) [expected/got 1]
[32mPASS[37m: [44].delete_at(0) should return 44 [expected/got 44]
[32mPASS[37m: #length after [44].delete_at(0) [expected/got 0]
[32mPASS[37m: member? should return true if an element exists in the array [expected/got true]
[32mPASS[37m: b=[42,43]; b[0] should return 42 [expected/got 42]
[32mPASS[37m: b=[42,43]; b[-1] should return 43 [expected/got 43]
[32mPASS[37m: b=[42,43]; b[1..-1] should return [43] [expected/got "[43]"]
[32mPASS[37m: Array#reverse should reverse an array [expected/got "[4, 3, 2, 1]"]
[32mPASS[37m: Array#partition should split an array in two based on provided block [expected/got "[[42, 5], [2, 1]]"]
[32mPASS[37m: Array#sort_by (ascending) [expected/got "[1, 2, 3, 42]"]
[32mPASS[37m: Array#sort_by (descending) [expected/got [42, 3, 2, 1]]
[32mPASS[37m: Fixnum#<=>(42,2) [expected/got 1]
[32mPASS[37m: Fixnum#<=>(42,3) [expected/got 1]
[32mPASS[37m: Fixnum#<=>(42,1) [expected/got 1]
[32mPASS[37m: Fixnum#<=>(2,3) [expected/got -1]
[32mPASS[37m: Fixnum#<=>(2,2) [expected/got 0]
[32mPASS[37m: Fixnum#<=>(3,1) [expected/got 1]
[32mPASS[37m: Array#==: Two Array's where each element compares the same should return true [expected/got true]
[32mPASS[37m: Array#sort [expected/got [:a, :b, :d, :e, :f, :foo]]
[32mPASS[37m: Array#sort (ascending) [expected/got "[1, 2, 3, 42]"]
[32mPASS[37m: Array#sort (strings) [expected/got "[\"nil\", \"sp\", \"true\"]"]
[32mPASS[37m: Array#sort (symbols) [expected/got "[:nil, :sp, :true]"]
[32mPASS[37m: Array(42) should return [42] [expected/got "[42]"]
[32mPASS[37m: Array#insert with a positive offset should insert its argument *before* the value at the offset [expected/got "[0, 1, 42, 2, 3, 4]"]
[32mPASS[37m: Array#insert with an offset larger than the array should cause 'nil's to be inserted to expand the array accordingly [expected/got "[0, 1, 2, nil, 42]"]
[32mPASS[37m: Array#insert with -1 as offset is the same as appending an entry at the end [expected/got "[0, 1, 2, 42]"]
[32mPASS[37m: Array#insert with a negative offset is the same as counting that many places from the right, and then inserting the entry *after* that position [expected/got "[0, 1, 42, 2]"]
[32mPASS[37m: Array with a single symbol [expected/got "[:stackframe]"]
[32mPASS[37m: [:stackframe][1] should return nil [expected/got "nil"]
[32mPASS[37m: [:stackframe][-1] should return :stackframe [expected/got ":stackframe"]
[32mPASS[37m: [:stackframe][1..-1] should return [] [expected/got "[]"]
[32mPASS[37m: Subtracting identical arrays should return [] [expected/got "[]"]
[32mPASS[37m: Subtracting part of an array should return the rest [expected/got "[:a, :c]"]
[32mPASS[37m: Array#zip should merge the array with an enumerable [expected/got "[[:a, 1], [:b, 2], [:c, 3]]"]
[32mPASS[37m: Flatten on a flat Array is a noop [expected/got [:a]]
[32mPASS[37m: Array#flatten on a nested array [expected/got [:a, :b, :c]]
[32mPASS[37m: Array#flatten on a more deeply nested array [expected/got [:a, :b, :c]]
[32mPASS[37m: Array#flatten(1)q on a more deeply nested array [expected/got [:a, :b, [:c]]]
[32mPASS[37m: Array#[]: Single element range [expected/got [:b]]
[32mPASS[37m: Array#[]: Range extending past the end [expected/got [:b]]
[32mPASS[37m: Array#[]: Two element range [expected/got [:b, :c]]
[32mPASS[37m: Array#[]: Three element range [expected/got [:b, :c, :d]]
[32mPASS[37m: Array#[]: Range hitting end [expected/got [:c, :d, :e]]
[32mPASS[37m: Subtracting an array from a Set [expected/got "#<Set: {:b, :c}>"]
[32mPASS[37m: Chained subtration of arrays from a Set [expected/got "#<Set: {:b}>"]
[32mPASS[37m: Second addition of pre-existing value to Set [expected/got "#<Set: {:a, :b, :c}>"]
[32mPASS[37m: Verifying that Hash returns default specified default value for unknown key [expected/got 42]
[32mPASS[37m: Insert single key into Hash [expected/got "{:foo=>:bar}"]
[32mPASS[37m: Inserting second key maintains insertion order [expected/got "{:foo=>:bar, :a=>:b}"]
[32mPASS[37m: Replacing first inserted key maintains original insertion order [expected/got "{:foo=>:baz, :a=>:b}"]
[32mPASS[37m: Additional insertion after overwrite [expected/got "{:foo=>:baz, :a=>:b, :b=>:c}"]
[32mPASS[37m: Collect should return Hash values in insertion order [expected/got "[[:foo, :baz], [:a, :b], [:b, :c]]"]
[32mPASS[37m: Additional additions [expected/got "{:foo=>:baz, :a=>:b, :b=>:c, :d=>:e, :e=>:f, :f=>:g}"]
[32mPASS[37m: #keys [expected/got "[:foo, :a, :b, :d, :e, :f]"]
[32mPASS[37m: #keys post-delete [expected/got "[:foo, :a, :b, :e, :f]"]
[32mPASS[37m: #keys post-delete and re-insert [expected/got "[:foo, :a, :b, :e, :f, :d]"]
[32mPASS[37m: and another delete [expected/got "[:a, :b, :e, :f, :d]"]
[32mPASS[37m: Return value of delete [expected/got :h]
[32mPASS[37m: and another delete [expected/got "[:a, :b, :e, :f]"]
[32mPASS[37m: delete nil [expected/got nil]
[32mPASS[37m: Return value of delete [expected/got :c]
[32mPASS[37m: and another delete [expected/got "[:a, :e, :f]"]
[32mPASS[37m: #to_a after deletes [expected/got "[[:a, :b], [:e, :f], [:f, :g]]"]
[32mPASS[37m: Last element [expected/got "[[:f, :g]]"]
[32mPASS[37m: A while loop without an explicit return should evaluation to nil [expected/got nil]
[32mPASS[37m: mockio.is_a?(File) [expected/got false]
[32mPASS[37m: File.file?(MockIO.new [expected/got false]
[32mPASS[37m: ScannerString and String with same contents [expected/got "Test"]
[32mPASS[37m: Scanner#position#lineno starts at 1 [expected/got 1]
[32mPASS[37m: Scanner#position#col starts at 1 [expected/got 1]
[32mPASS[37m: Scanner#filename for non-file IO [expected/got "<stream>"]
[32mPASS[37m: scanner.peek on 'This is a test' [expected/got 84]
[32mPASS[37m: Scanner#peek does not move the column [expected/got 1]
[32mPASS[37m: scanner.get on 'This is a test' [expected/got "T"]
[32mPASS[37m: Scanner#get does move the column [expected/got 2]
[32mPASS[37m: scanner.get with 'his is a test' remaining [expected/got "h"]
[32mPASS[37m: Scanner#get does move the column (2) [expected/got 3]
[32mPASS[37m: Scanner#unget does move the column back [expected/got 2]
[32mPASS[37m: scanner.get with 'his is a test' remaining after unget [expected/got "h"]
[32mPASS[37m: scanner.expect('is') with 'is a test' remaining [expected/got "is"]
[32mPASS[37m: scanner.expect('x') after having consumed the whole string should return nil [expected/got false]
[32mPASS[37m: Scanner position after LF should be 1 [expected/got 1]
[32mPASS[37m: Scanner lineno should increase [expected/got 2]
[32mPASS[37m: Unget of a line with LF should reduce lineno [expected/got 1]
[32mPASS[37m: A failed Scanner#expect should not change the line numbe__cnt: 1000
r [expected/got 1]
[32mPASS[37m: parser.expect('This') [expected/got "This"]
[32mPASS[37m: Skip whitespace [expected/got nil]
[32mPASS[37m: parser.expect('is') after skipping whitespace [expected/got "is"]
[32mPASS[37m: Parse symbol :sym [expected/got :":sym"]
[32mPASS[37m: Parse atom :sym [expected/got :":sym"]
[32mPASS[37m: Object.new.respond_to?(:foo)? [expected/got false]
[32mPASS[37m: Object.new.respond_to?(:inspect)? [expected/got true]
[32mPASS[37m: Parsing %s(this is a test) [expected/got "[:sexp, [:this, :is, :a, :test]]"]
[32mPASS[37m: Parsing %s(index self -4) [expected/got "[:sexp, [:index, :self, -4]]"]
[32mPASS[37m: esc [expected/got 27]
[32mPASS[37m: esc 2 [expected/got 27]
[32mPASS[37m: esc 3 [expected/got 9]
[32mPASS[37m: esc 4 [expected/got 92]
[32mPASS[37m: esc 5 [expected/got 10]
[32mPASS[37m: esc 6 [expected/got "e"]
[32mPASS[37m: Inspect [expected/got "\"\\\\e\""]
[32mPASS[37m: Expect Scanner#expect to return quoted backslash [expected/got "\\"]
[32mPASS[37m: Expect double-quoted string with backslash-e to translate to esc [expected/got 27]
[32mPASS[37m: Expect Scanner.expect(esc) to return esc when string is esc [expected/got "\e"]
[32mPASS[37m: Expect Scanner#expect to find backslash in single-quoted '\e' [expected/got "\\"]
[32mPASS[37m: Tokens::Quotes need to be able to handle escapes [expected/got "\e and more"]
[32mPASS[37m: __flag= is a legal method name [expected/got ":__flag="]
[32mPASS[37m: Shunting 1 [expected/got "[:+, 5, 1]"]
[32mPASS[37m: Shunting 2 [expected/got "[:+, 5, :y]"]
[32mPASS[37m: Shunting 3 [expected/got "[:+, 5, [:*, 1, 2]]"]
[32mPASS[37m: Shunting foo.bar(x) {} [expected/got "[:callm, :foo, :bar, [:x], [:proc]]"]
[32mPASS[37m:  [expected/got "[:callm, :x, :y, 42]"]
[32mPASS[37m: Parsing '%s(this is a test)' with the full parser [expected/got "[:do, [:sexp, [:this, :is, :a, :test]]]"]
[32mPASS[37m: Parsing '5 + a' with the full parser [expected/got "[:do, [:+, 5, :a]]"]
[32mPASS[37m: Parsing 'puts 'Hello World'' with the full parser [expected/got "[:do, [:call, :puts, [\"Hello World\"]]]"]
[32mPASS[37m: Parsing 'def foo; end' with the full parser [expected/got "[:do, [:defm, :foo, [], []]]"]
[32mPASS[37m: Parsing 'def foo; puts 'Hello World'; end' with the full parser [expected/got "[:do, [:defm, :foo, [], [[:call, :puts, [\"Hello World\"]]]]]"]
[32mPASS[37m: Parsing 'e[i]' with the full parser [expected/got "[:do, [:callm, :e, :[], [:i]]]"]
[32mPASS[37m: Parsing 'e[i] = E[:foo]' with the full parser [expected/got "[:do, [:callm, :e, :[]=, [:i, [:callm, :E, :[], [:\":foo\"]]]]]"]
[32mPASS[37m: Parsing '"\e"' with the full parser [expected/got "[:do, \"\\e\"]"]
[32mPASS[37m: Parsing 'Set[* e[2].to_a]' with the full parser [expected/got "[:do, [:callm, :Set, :[], [[:splat, [:callm, [:callm, :e, :[], [2]], :to_a]]]]]"]
[32mPASS[37m: Parsing 'def foo; name.gsub(foo.bar) { }; end ' with the full parser [expected/got "[:do, [:defm, :foo, [], [[:callm, :name, :gsub, [[:callm, :foo, :bar]], [:proc]]]]]"]
[32mPASS[37m: Parsing 'STDERR.puts "defm: #{args.inspect}"' with the full parser [expected/got "[:do, [:callm, :STDERR, :puts, [[:concat, \"defm: \", [:callm, :args, :inspect]]]]]"]
[32mPASS[37m: Parsing 'STDERR.puts "test"' with the full parser [expected/got "[:do, [:callm, :STDERR, :puts, \"test\"]]"]
[32mPASS[37m: Parsing 'STDERR.puts("test")' with the full parser [expected/got "[:do, [:callm, :STDERR, :puts, [\"test\"]]]"]
[32mPASS[37m: Parsing 'self.== other' with the full parser [expected/got "[:do, [:callm, :self, :==, :other]]"]
[32mPASS[37m: Parsing 'a - b - c' with the full parser [expected/got "[:do, [:-, [:-, :a, :b], :c]]"]
[32mPASS[37m: Parsing 'a + b + c' with the full parser [expected/got "[:do, [:+, [:+, :a, :b], :c]]"]
[32mPASS[37m: Parsing 'a * b * c' with the full parser [expected/got "[:do, [:*, [:*, :a, :b], :c]]"]
[32mPASS[37m: Parsing 'a / b / c' with the full parser [expected/got "[:do, [:/, [:/, :a, :b], :c]]"]
[32mPASS[37m: Parsing '1..x.size' with the full parser__cnt: 2000
__cnt: 3000
__cnt: 4000
__cnt: 5000
__cnt: 6000
__cnt: 7000
__cnt: 8000
__cnt: 9000
__cnt: 10000
 [expected/got "[:do, [:range, 1, [:callm, :x, :size]]]"]
[32mPASS[37m: Parsing 'foo.bar(x)' with the full parser [expected/got "[:do, [:callm, :foo, :bar, [:x]]]"]
[32mPASS[37m: Parsing 'foo.bar(x) {}' with the full parser [expected/got "[:do, [:callm, :foo, :bar, [:x], [:proc]]]"]
[32mPASS[37m: Parsing 'def flatten level=0; end' with the full parser [expected/got "[:do, [:defm, :flatten, [[:level, :default, 0]], []]]"]
[32mPASS[37m: Parsing '{ :foo => 42, } ' with the full parser [expected/got "[:do, [:hash, [:pair, :\":foo\", 42]]]"]
[32mPASS[37m: Parser position [expected/got 2]
[32mPASS[37m: Parser line number should match [expected/got 4]
[32mPASS[37m: Parsing '5 +
2' with the full parser [expected/got "[:do, [:+, 5, 2]]"]
[32mPASS[37m: Parsing '5 
-2' with the full parser [expected/got "[:do, 5, -2]"]
[32mPASS[37m: Parsing 'a = 5
b = -2' with the full parser [expected/got "[:do, [:assign, :a, 5], [:assign, :b, -2]]"]
[32mPASS[37m: Parsing '1
2
3' with the full parser [expected/got "[:do, 1, 2, 3]"]
[32mPASS[37m: Parsing 'class Foo
end
' with the full parser [expected/got "[:do, [:class, :Foo, :Object, []]]"]
[32mPASS[37m: Scanner should be at EOF after parsing '5\n' [expected/got "nil"]
[32mPASS[37m: Scanner should be at EOF after parsing class with nested ends [expected/got "nil"]
[32mPASS[37m: Parsing '4.ceildiv(-3)
-4.ceildiv(3)' with the full parser [expected/got "[:do, [:callm, 4, :ceildiv, [-3]], [:callm, -4, :ceildiv, [3]]]"]
[32mPASS[37m: Minimal EOF bug reproducer should parse to EOF [expected/got "nil"]
[32mPASS[37m: 4 + (-3) should equal 1 [expected/got 1]
[32mPASS[37m: -4 + 3 should equal -1 [expected/got -1]
[32mPASS[37m: First expression should be 5 [expected/got 5]
[32mPASS[37m: Second expression should be -2 [expected/got -2]
[32mPASS[37m: Parsing 'a,b = [42,123]' with the full parser [expected/got "[:do, [:assign, [:destruct, :a, :b], [:array, 42, 123]]]"]
[32mPASS[37m: depth_first [expected/got "to get here"]
[32mPASS[37m: #depth_first should descent into each array [expected/got "[[:if, [:a, :b], [:do, :c]], [:a, :b], [:do, :c]]"]
[32mPASS[37m: String#gsub - Simple character substitution [expected/got "fxx"]
[32mPASS[37m: String#gsub - Replace character with string [expected/got "fxyxy"]
[32mPASS[37m: String#gsub - Replace character with string with escape characters [expected/got "foo\\nbar"]
[32mPASS[37m: String#<=> should return 1 if left string sorts after right string [expected/got 1]
[32mPASS[37m: String#<=> should return 1 for 'foo' <=> 'f' [expected/got 1]
[32mPASS[37m: String#split(' ') should return an array of the split string [expected/got ["foo", "bar", "baz"]]
[32mPASS[37m: Expanding path wo/trailing / on base [expected/got "/app/lib/core/string.rb"]
[32mPASS[37m: Expanding path w/trailing / on base [expected/got "/app/lib/core/string.rb"]
[32mPASS[37m: Expanding path w/repeated slash [expected/got "/app/lib/core"]
[32mPASS[37m: Basic dirname [expected/got "/app/examples"]
[32mPASS[37m: Basic basename [expected/got "case.rb"]
[32mPASS[37m: Compiler#find_vars [expected/got "[[:foo], #<Set: {:arg}>]"]
[32mPASS[37m: Parse 'def __flag=(x)' without leaving out the = [expected/got "[:do, [:defm, :__flag=, [:x], [42]]]"]
[32mPASS[37m: concat => callm (2) [expected/got "[:do, [:if, [:<, :a, 2], [:do, [:callm, :STDERR, :puts, [[:callm, [:callm, [:callm, \"a \", :to_s], :concat, [[:callm, :b, :to_s]]], :concat, [[:callm, \" c\", :to_s]]]]]]]]"]
[32mPASS[37m: find_vars should identify all variables in a proc [expected/got "[[], #<Set: {:h}>]"]
[32mPASS[37m: find_vars_should identify all variables in a proc [expected/got "[[:left], #<Set: {:scope, :right}>]"]
[32mPASS[37m: find_vars_should identify all variables in a proc [expected/got "[[:left], #<Set: {:scope, :right}>]"]
[32mPASS[37m: find_vars_should identify all variables in a proc [x] [expected/got "[[:left], #<Set: {:scope, :right}>]"]
[32mPASS[37m: find_vars should identify all variables in a proc [expected/got "[[], #<Set: {:arg, :arg2}>]"]
[32mPASS[37m: find_vars should identify all variables references in method body [expected/got "[[], #<Set: {:arg, :arg2}>]"]
[32mPASS[37m: yield triggers a rewrite even with no arguments [expected/got "[:let, [:__env__, :__tmp_proc], [:sexp, [:assign, :__env__, [:call, :__alloc_env, 2]]], [:assign, [:index, :__env__, 1], :__closure__], [:callm, [:index, :__env__, 1], :call, nil]]"]
DONE
Fails: 0
