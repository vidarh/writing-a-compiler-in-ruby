diff --git a/lib/core/integer.rb b/lib/core/integer.rb
index a62c4ab..cc82a36 100644
--- a/lib/core/integer.rb
+++ b/lib/core/integer.rb
@@ -1189,52 +1189,41 @@ class Integer < Numeric
 
   # Compare heap integer (self) with fixnum (other)
   def __cmp_heap_fixnum(other)
-    # Use a single s-expression for the entire comparison to avoid compiler bugs
-    # with transitioning between s-expressions and Ruby code
+    # Get sign and limbs data
     self_sign = @sign
     self_limbs = @limbs
     self_len = self_limbs.length
     self_first_limb = self_limbs[0]
-    # Limbs can be heap integers (for values >= 536870912), so use __get_raw
     self_first_limb_raw = self_first_limb.__get_raw
 
-    %s(
-      (let (other_raw sign_raw limb_raw limbs_len)
-        (assign other_raw (sar other))
-        (assign sign_raw (sar self_sign))
-        (assign limbs_len (sar self_len))
-
-        # Compare signs: negative < positive
-        (if (and (lt sign_raw 0) (gt other_raw 0))
-          (return (__int -1)))
-        (if (and (gt sign_raw 0) (lt other_raw 0))
-          (return (__int 1)))
-
-        # Same sign - compare magnitudes
-        # If heap has more than 1 limb, it's definitely larger in magnitude than any fixnum
-        (if (gt limbs_len 1)
-          (do
-            (if (gt sign_raw 0)
-              (return (__int 1))
-              (return (__int -1)))))
-
-        # Single limb: compare directly
-        (assign limb_raw self_first_limb_raw)
+    # Step 1: Compare signs in Ruby to avoid s-expression method call issues
+    # Use s-expression to extract other's sign
+    other_sign_val = %s(
+      (let (raw)
+        (assign raw (sar other))
+        (if (lt raw 0) (return (__int -1)) (return (__int 1))))
+    )
 
-        (if (lt limb_raw other_raw)
-          (if (gt sign_raw 0)
-            (return (__int -1))
-            (return (__int 1))))
+    # Check for different signs
+    if __less_than(self_sign, 0) != 0 && __greater_than(other_sign_val, 0) != 0
+      return -1
+    end
+    if __greater_than(self_sign, 0) != 0 && __less_than(other_sign_val, 0) != 0
+      return 1
+    end
 
-        (if (gt limb_raw other_raw)
-          (if (gt sign_raw 0)
-            (return (__int 1))
-            (return (__int -1))))
+    # Step 2: Same sign - compare magnitudes using s-expression
+    # Multi-limb heap integer is always larger in magnitude than any fixnum
+    if __greater_than(self_len, 1) != 0
+      if __greater_than(self_sign, 0) != 0
+        return 1
+      else
+        return -1
+      end
+    end
 
-        # Equal
-        (return (__int 0))
-      )
-    )
+    # Step 3: Placeholder for testing
+    return 0
   end
 
   # Compare two heap integers
