diff --git a/transform.rb b/transform.rb
index 20f90e4..4751b66 100644
--- a/transform.rb
+++ b/transform.rb
@@ -228,23 +228,33 @@ class Compiler
   end
 
   # FIXME: Rewrite using "depth first"?
-  def find_vars(e, scopes, env, freq, in_lambda = false, in_assign = false)
+  def find_vars(e, scopes, env, freq, in_lambda = false, in_assign = false, lambda_params = [])
     return [],env, false if !e
     e = [e] if !e.is_a?(Array)
     e.each do |n|
       if n.is_a?(Array)
         if n[0] == :assign
-          vars1, env1 = find_vars(n[1],     scopes + [Set.new],env, freq, in_lambda, true)
-          vars2, env2 = find_vars(n[2..-1], scopes + [Set.new],env, freq, in_lambda)
+          vars1, env1 = find_vars(n[1],     scopes + [Set.new],env, freq, in_lambda, true, lambda_params)
+          vars2, env2 = find_vars(n[2..-1], scopes + [Set.new],env, freq, in_lambda, false, lambda_params)
           env = env1 + env2
           vars = vars1+vars2
           vars.each {|v| push_var(scopes,env,v) if !is_special_name?(v) }
         elsif n[0] == :lambda || n[0] == :proc
-          vars, env2= find_vars(n[2], scopes + [Set.new],env, freq, true)
+          params = n[1] || []
+          # Pass current params to nested processing so they can be captured
+          # But add them to scope so they're visible to nested lambdas
+          param_scope = Set.new(params)
+
+          # Protect parameter list from rewriting by marking it
+          if n[1].is_a?(Array) && !n[1].empty?
+            n[1] = E[:__PARAMS__, *n[1]]
+          end
+
+          vars, env2= find_vars(n[2], scopes + [param_scope],env, freq, true, false, params)
 
-          # Clean out proc/lambda arguments from the %s(let ..) and the environment we're building
-          vars  -= n[1] if n[1]
-          env2  -= n[1] if n[1]
+          # Clean out proc/lambda arguments from the %s(let ..)
+          vars  -= params
+          # Don't remove params from env2 - if they ended up there, nested lambdas need them
           env += env2
 
           n[2] = E[n.position,:let, vars, *n[2]] if n[2]
@@ -252,13 +262,13 @@ class Compiler
           if    n[0] == :callm
             # Wrap receiver if it's an array (AST node) to prevent element-by-element iteration
             receiver = n[1].is_a?(Array) ? [n[1]] : n[1]
-            vars, env = find_vars(receiver, scopes, env, freq, in_lambda)
+            vars, env = find_vars(receiver, scopes, env, freq, in_lambda, false, lambda_params)
 
             if n[3]
               nodes = n[3]
               nodes = [nodes] if !nodes.is_a?(Array)
               nodes.each do |n2|
-                vars2, env2 = find_vars([n2], scopes+[Set.new], env, freq, in_lambda)
+                vars2, env2 = find_vars([n2], scopes+[Set.new], env, freq, in_lambda, false, lambda_params)
                 vars += vars2
                 env  += env2
               end
@@ -266,31 +276,31 @@ class Compiler
 
             # If a block is provided, we need to find variables there too
             if n[4]
-              vars3, env3 = find_vars([n[4]], scopes, env, freq, in_lambda)
+              vars3, env3 = find_vars([n[4]], scopes, env, freq, in_lambda, false, lambda_params)
               vars += vars3
               env  += env3
             end
           elsif    n[0] == :call
             # Wrap receiver if it's an array (AST node) to prevent element-by-element iteration
             receiver = n[1].is_a?(Array) ? [n[1]] : n[1]
-            vars, env = find_vars(receiver, scopes, env, freq, in_lambda)
+            vars, env = find_vars(receiver, scopes, env, freq, in_lambda, false, lambda_params)
             if n[2]
               nodes = n[2]
               nodes = [nodes] if !nodes.is_a?(Array)
               nodes.each do |n2|
-                vars2, env2 = find_vars([n2], scopes+[Set.new], env, freq, in_lambda)
+                vars2, env2 = find_vars([n2], scopes+[Set.new], env, freq, in_lambda, false, lambda_params)
                 vars += vars2
                 env  += env2
               end
             end
 
             if n[3]
-              vars2, env2 = find_vars([n[3]], scopes, env, freq, in_lambda)
+              vars2, env2 = find_vars([n[3]], scopes, env, freq, in_lambda, false, lambda_params)
               vars += vars2
               env  += env2
             end
           else
-            vars, env = find_vars(n[1..-1], scopes, env, freq, in_lambda)
+            vars, env = find_vars(n[1..-1], scopes, env, freq, in_lambda, false, lambda_params)
           end
 
           vars.each {|v| push_var(scopes,env,v); }
@@ -301,8 +311,12 @@ class Compiler
         if sc.size == 0
           push_var(scopes,env,n) if in_assign && !is_special_name?(n)
         elsif in_lambda
-          sc.first.delete(n)
-          env << n
+          # Don't capture if it's a parameter of the CURRENT lambda
+          # Only capture if it's from an outer scope
+          unless lambda_params.include?(n)
+            sc.first.delete(n)
+            env << n
+          end
         end
       end
     end
@@ -317,6 +331,11 @@ class Compiler
   def rewrite_env_vars(exp, env)
     seen = false
     exp.depth_first do |e|
+      # Skip protected parameter lists
+      if e.is_a?(Array) && e[0] == :__PARAMS__
+        next :skip
+      end
+
       # We need to expand "yield" before we rewrite.
       if e.is_a?(Array) && e[0] == :call && e[1] == :yield
         seen = true
@@ -331,9 +350,11 @@ class Compiler
       eary = e
       e.each_with_index do |ex, i|
         # FIXME: This is necessary in order to avoid rewriting compiler keywords in some
-        # circumstances. The proper solution would be to introduce more types of 
+        # circumstances. The proper solution would be to introduce more types of
         # expression nodes in the parser
         next if i == 0 && ex == :index
+        # Don't rewrite lambda/proc parameter lists (position 1)
+        next if i == 1 && (e[0] == :lambda || e[0] == :proc)
         num = env.index(ex)
         if num
           seen = true
@@ -414,6 +435,13 @@ class Compiler
       if env.size > 0
         seen = rewrite_env_vars(body, aenv)
 
+        # Unwrap protected parameter lists
+        body.depth_first do |node|
+          if node.is_a?(Array) && node[0] == :__PARAMS__
+            node.replace(node[1..-1])
+          end
+        end
+
         notargs = env - args - [:__closure__]
 
         # FIXME: Due to compiler bug
