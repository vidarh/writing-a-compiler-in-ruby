diff --git a/transform.rb b/transform.rb
index 20f90e4..de68834 100644
--- a/transform.rb
+++ b/transform.rb
@@ -240,11 +240,14 @@ class Compiler
           vars = vars1+vars2
           vars.each {|v| push_var(scopes,env,v) if !is_special_name?(v) }
         elsif n[0] == :lambda || n[0] == :proc
-          vars, env2= find_vars(n[2], scopes + [Set.new],env, freq, true)
-
-          # Clean out proc/lambda arguments from the %s(let ..) and the environment we're building
-          vars  -= n[1] if n[1]
-          env2  -= n[1] if n[1]
+          params = n[1] || []
+          # Add parameters to scope so nested lambdas can capture them
+          param_scope = Set.new(params)
+          vars, env2= find_vars(n[2], scopes + [param_scope],env, freq, true)
+
+          # Clean out proc/lambda arguments from the %s(let ..)
+          vars  -= params
+          # Don't remove params from env2 - if they ended up there, nested lambdas need them
           env += env2
 
           n[2] = E[n.position,:let, vars, *n[2]] if n[2]
@@ -317,6 +320,12 @@ class Compiler
   def rewrite_env_vars(exp, env)
     seen = false
     exp.depth_first do |e|
+      # Skip lambda/proc nodes entirely - they'll be transformed to :defun
+      # and processed separately by rewrite_let_env
+      if e.is_a?(Array) && (e[0] == :lambda || e[0] == :proc)
+        next :skip
+      end
+
       # We need to expand "yield" before we rewrite.
       if e.is_a?(Array) && e[0] == :call && e[1] == :yield
         seen = true
@@ -331,7 +340,7 @@ class Compiler
       eary = e
       e.each_with_index do |ex, i|
         # FIXME: This is necessary in order to avoid rewriting compiler keywords in some
-        # circumstances. The proper solution would be to introduce more types of 
+        # circumstances. The proper solution would be to introduce more types of
         # expression nodes in the parser
         next if i == 0 && ex == :index
         num = env.index(ex)
