#!/bin/bash
# run_rubyspec - Compile and run rubyspec files or directories

# Suppress bash job control messages
set +m 2>/dev/null

if [ $# -eq 0 ]; then
    echo "Usage: ./run_rubyspec <spec_file_or_directory>"
    echo "Example: ./run_rubyspec rubyspec/core/integer/even_spec.rb"
    echo "         ./run_rubyspec rubyspec/core/integer/"
    exit 1
fi

TARGET="$1"

echo "DEBUG: Starting run_rubyspec for $TARGET" >&2

# Function to run a single spec file
run_single_spec() {
    local SPEC_FILE="$1"
    local SPEC_NAME=$(basename "$SPEC_FILE" .rb)
    local TEMP_SPEC="rubyspec_temp_${SPEC_NAME}.rb"
    local VERBOSE="${2:-0}"

    # Replace the spec_helper require with our own
    echo "require 'rubyspec_helper'" > "$TEMP_SPEC"
    echo "" >> "$TEMP_SPEC"

    # Process fixtures first - scan spec file and shared files for fixture requires
    # and inline all fixtures at TOP LEVEL (before def run_specs)
    SPEC_DIR=$(dirname "$SPEC_FILE")

    # First pass: find and inline all fixture files
    while IFS= read -r line; do
        if echo "$line" | grep -q "require_relative.*fixtures"; then
            # Extract the fixture file path
            FIXTURE_FILE=$(echo "$line" | sed "s/.*require_relative *['\"]\\([^'\"]*\\)['\"].*/\\1.rb/")
            FIXTURE_PATH="$SPEC_DIR/$FIXTURE_FILE"
            if [ -f "$FIXTURE_PATH" ]; then
                cat "$FIXTURE_PATH" >> "$TEMP_SPEC"
                echo "" >> "$TEMP_SPEC"
            fi
        fi
        if echo "$line" | grep -q "require_relative.*shared"; then
            # Also check shared files for fixture requires
            SHARED_FILE=$(echo "$line" | sed "s/.*require_relative *['\"]\\([^'\"]*\\)['\"].*/\\1.rb/")
            SHARED_PATH="$SPEC_DIR/$SHARED_FILE"
            if [ -f "$SHARED_PATH" ]; then
                while IFS= read -r shared_line; do
                    if echo "$shared_line" | grep -q "require_relative.*fixtures"; then
                        FIXTURE_FILE=$(echo "$shared_line" | sed "s/.*require_relative *['\"]\\([^'\"]*\\)['\"].*/\\1.rb/")
                        # Resolve relative path from shared file's directory
                        SHARED_DIR=$(dirname "$SHARED_PATH")
                        FIXTURE_PATH="$SHARED_DIR/$FIXTURE_FILE"
                        if [ -f "$FIXTURE_PATH" ]; then
                            cat "$FIXTURE_PATH" >> "$TEMP_SPEC"
                            echo "" >> "$TEMP_SPEC"
                        fi
                    fi
                done < "$SHARED_PATH"
            fi
        fi
    done < "$SPEC_FILE"

    # Now start the run_specs method - shared examples and spec content go inside
    echo "" >> "$TEMP_SPEC"
    echo "def run_specs" >> "$TEMP_SPEC"

    # Second pass: process shared example requires - load them inline INSIDE the method
    # (blocks at top level are buggy)
    while IFS= read -r line; do
        if echo "$line" | grep -q "require_relative.*shared"; then
            # Extract the shared file path
            SHARED_FILE=$(echo "$line" | sed "s/.*require_relative *['\"]\\([^'\"]*\\)['\"].*/\\1.rb/")
            SHARED_PATH="$SPEC_DIR/$SHARED_FILE"
            if [ -f "$SHARED_PATH" ]; then
                # Include shared file content, filtering out require_relative lines,
                # converting keyword args to hash syntax,
                # replacing @method with $spec_shared_method, and adding parentheses (bug workaround)
                cat "$SHARED_PATH" | \
                    grep -v "require_relative" | \
                    sed "s/, *shared: *true *do/, {:shared => true} do/" | \
                    sed "s/@method/\$spec_shared_method/g" | \
                    sed 's/^\([[:space:]]*\)describe \(.*\) do$/\1describe(\2) do/' \
                    >> "$TEMP_SPEC"
                echo "" >> "$TEMP_SPEC"
            fi
        fi
    done < "$SPEC_FILE"

    # Filter out require_relative lines and append the spec content
    # WORKAROUND: Add parentheses to describe/it_behaves_like calls to avoid compiler bug
    # Bug: calling func without parens when func has default param + &block causes segfault
    # WORKAROUND: Rewrite instance variables to global variables since instance_eval is not implemented
    # This allows 'before :each' blocks to work by using globals instead of instance vars
    cat "$SPEC_FILE" | grep -v "require_relative" | \
        sed 's/^\([[:space:]]*\)describe \(.*\) do$/\1describe(\2) do/' | \
        sed 's/^\([[:space:]]*\)it_behaves_like \(.*\)$/\1it_behaves_like(\2)/' | \
        sed 's/@\([a-zA-Z_][a-zA-Z0-9_]*\)/$spec_\1/g' \
        >> "$TEMP_SPEC"
    echo "end" >> "$TEMP_SPEC"
    echo "" >> "$TEMP_SPEC"
    echo "run_specs" >> "$TEMP_SPEC"
    echo "print_spec_results" >> "$TEMP_SPEC"

    if [ "$VERBOSE" -eq 1 ]; then
        echo -n "Compiling $(basename $SPEC_FILE)... "
    fi

    ./compile "$TEMP_SPEC" -I. < /dev/null > /dev/null 2>&1

    if [ $? -eq 0 ]; then
        # The binary name is based on the temp file name
        TEMP_SPEC_NAME=$(basename "$TEMP_SPEC" .rb)
        bash -c "./out/${TEMP_SPEC_NAME} < /dev/null > /tmp/spec_output_$$ 2>&1" 2>/dev/null
        EXIT_CODE=$?

        if [ "$VERBOSE" -eq 1 ]; then
            cat /tmp/spec_output_$$
            echo
        fi

        # Save output to a file that can be read by the caller
        cat /tmp/spec_output_$$ > "/tmp/spec_last_output_$$"
        rm -f /tmp/spec_output_$$
        # rm -f "$TEMP_SPEC"

        if [ $EXIT_CODE -eq 136 ] || [ $EXIT_CODE -eq 139 ]; then
            # 136 = SIGFPE (Floating point exception), 139 = SIGSEGV (Segmentation fault)
            return 2
        fi
        return $EXIT_CODE
    else
        if [ "$VERBOSE" -eq 1 ]; then
            echo "✗ (compilation failed)"
        fi
        # rm -f "$TEMP_SPEC"
        return 3
    fi
}

# Check if target is a directory
if [ -d "$TARGET" ]; then
    echo "Running all specs in $TARGET..."
    echo "================================"
    echo

    TOTAL_FILES=0
    PASSED=0
    FAILED_COMPILE=0
    SEGFAULT=0
    FAILED=0

    # Individual test case counters
    TOTAL_TESTS_PASSED=0
    TOTAL_TESTS_FAILED=0
    TOTAL_TESTS_SKIPPED=0
    TOTAL_TESTS_TOTAL=0

    # Find all .rb files recursively, excluding shared/ directories
    while IFS= read -r -d '' SPEC_FILE; do
        TOTAL_FILES=$((TOTAL_FILES + 1))

        run_single_spec "$SPEC_FILE" 0
        RESULT=$?

        # Read the saved output to extract test counts
        SPEC_OUTPUT=""
        if [ -f "/tmp/spec_last_output_$$" ]; then
            SPEC_OUTPUT=$(cat "/tmp/spec_last_output_$$")
            rm -f "/tmp/spec_last_output_$$"
        fi

        if [ $RESULT -eq 0 ]; then
            echo -e "\e[32m[PASS] $SPEC_FILE"
            PASSED=$((PASSED + 1))
        elif [ $RESULT -eq 1 ]; then
            echo -e "\e[31m[FAIL] $SPEC_FILE"
            FAILED=$((FAILED + 1))
        elif [ $RESULT -eq 2 ]; then
            echo -e "\e[34m[SEGFAULT] $SPEC_FILE"
            SEGFAULT=$((SEGFAULT + 1))
        else
            echo -e "\e[33m[COMPILE FAIL] $SPEC_FILE"
            FAILED_COMPILE=$((FAILED_COMPILE + 1))
        fi

        # Extract individual test counts from output if available
        # Look for pattern: "X passed, Y failed, Z skipped (N total)"
        if echo "$SPEC_OUTPUT" | grep -q "passed.*failed.*skipped"; then
            PASSED_COUNT=$(echo "$SPEC_OUTPUT" | grep -o "[0-9]* passed" | grep -o "[0-9]*" | head -1)
            FAILED_COUNT=$(echo "$SPEC_OUTPUT" | grep -o "[0-9]* failed" | grep -o "[0-9]*" | head -1)
            SKIPPED_COUNT=$(echo "$SPEC_OUTPUT" | grep -o "[0-9]* skipped" | grep -o "[0-9]*" | head -1)
            TOTAL_COUNT=$(echo "$SPEC_OUTPUT" | grep -o "([0-9]* total)" | grep -o "[0-9]*" | head -1)

            if [ -n "$PASSED_COUNT" ]; then
                TOTAL_TESTS_PASSED=$((TOTAL_TESTS_PASSED + PASSED_COUNT))
            fi
            if [ -n "$FAILED_COUNT" ]; then
                TOTAL_TESTS_FAILED=$((TOTAL_TESTS_FAILED + FAILED_COUNT))
            fi
            if [ -n "$SKIPPED_COUNT" ]; then
                TOTAL_TESTS_SKIPPED=$((TOTAL_TESTS_SKIPPED + SKIPPED_COUNT))
            fi
            if [ -n "$TOTAL_COUNT" ]; then
                TOTAL_TESTS_TOTAL=$((TOTAL_TESTS_TOTAL + TOTAL_COUNT))
            fi
        fi
    done < <(find "$TARGET" -name "*_spec.rb" -type f -not -path "*/shared/*" -print0 | sort -z)

    echo
    echo "================================"
    echo "Summary:"
    echo "  Total spec files: $TOTAL_FILES"
    echo "  Passed: $PASSED"
    echo "  Failed: $FAILED"
    echo "  Segfault/Runtime error: $SEGFAULT"
    echo "  Failed to compile: $FAILED_COMPILE"
    echo
    echo "Individual Test Cases:"
    echo "  Total tests: $TOTAL_TESTS_TOTAL"
    echo "  Passed: $TOTAL_TESTS_PASSED"
    echo "  Failed: $TOTAL_TESTS_FAILED"
    echo "  Skipped: $TOTAL_TESTS_SKIPPED"
    if [ $TOTAL_TESTS_TOTAL -gt 0 ]; then
        PASS_PERCENT=$((TOTAL_TESTS_PASSED * 100 / TOTAL_TESTS_TOTAL))
        echo "  Pass rate: ${PASS_PERCENT}%"
    fi

elif [ -f "$TARGET" ]; then
    # Single file mode - show full output
    SPEC_FILE="$TARGET"
    SPEC_NAME=$(basename "$SPEC_FILE" .rb)
    TEMP_SPEC="rubyspec_temp_${SPEC_NAME}.rb"

    # Replace the spec_helper require with our own
    echo "require 'rubyspec_helper'" > "$TEMP_SPEC"
    echo "" >> "$TEMP_SPEC"

    # Process fixtures first - scan spec file and shared files for fixture requires
    # and inline all fixtures at TOP LEVEL (before def run_specs)
    SPEC_DIR=$(dirname "$SPEC_FILE")

    # First pass: find and inline all fixture files
    while IFS= read -r line; do
        if echo "$line" | grep -q "require_relative.*fixtures"; then
            # Extract the fixture file path
            FIXTURE_FILE=$(echo "$line" | sed "s/.*require_relative *['\"]\\([^'\"]*\\)['\"].*/\\1.rb/")
            FIXTURE_PATH="$SPEC_DIR/$FIXTURE_FILE"
            if [ -f "$FIXTURE_PATH" ]; then
                cat "$FIXTURE_PATH" >> "$TEMP_SPEC"
                echo "" >> "$TEMP_SPEC"
            fi
        fi
        if echo "$line" | grep -q "require_relative.*shared"; then
            # Also check shared files for fixture requires
            SHARED_FILE=$(echo "$line" | sed "s/.*require_relative *['\"]\\([^'\"]*\\)['\"].*/\\1.rb/")
            SHARED_PATH="$SPEC_DIR/$SHARED_FILE"
            if [ -f "$SHARED_PATH" ]; then
                while IFS= read -r shared_line; do
                    if echo "$shared_line" | grep -q "require_relative.*fixtures"; then
                        FIXTURE_FILE=$(echo "$shared_line" | sed "s/.*require_relative *['\"]\\([^'\"]*\\)['\"].*/\\1.rb/")
                        # Resolve relative path from shared file's directory
                        SHARED_DIR=$(dirname "$SHARED_PATH")
                        FIXTURE_PATH="$SHARED_DIR/$FIXTURE_FILE"
                        if [ -f "$FIXTURE_PATH" ]; then
                            cat "$FIXTURE_PATH" >> "$TEMP_SPEC"
                            echo "" >> "$TEMP_SPEC"
                        fi
                    fi
                done < "$SHARED_PATH"
            fi
        fi
    done < "$SPEC_FILE"

    # Now start the run_specs method - shared examples and spec content go inside
    echo "" >> "$TEMP_SPEC"
    echo "def run_specs" >> "$TEMP_SPEC"

    # Second pass: process shared example requires - load them inline INSIDE the method
    # (blocks at top level are buggy)
    while IFS= read -r line; do
        if echo "$line" | grep -q "require_relative.*shared"; then
            # Extract the shared file path
            SHARED_FILE=$(echo "$line" | sed "s/.*require_relative *['\"]\\([^'\"]*\\)['\"].*/\\1.rb/")
            SHARED_PATH="$SPEC_DIR/$SHARED_FILE"
            if [ -f "$SHARED_PATH" ]; then
                # Include shared file content, filtering out require_relative lines,
                # converting keyword args to hash syntax,
                # replacing @method with $spec_shared_method, and adding parentheses (bug workaround)
                cat "$SHARED_PATH" | \
                    grep -v "require_relative" | \
                    sed "s/, *shared: *true *do/, {:shared => true} do/" | \
                    sed "s/@method/\$spec_shared_method/g" | \
                    sed 's/^\([[:space:]]*\)describe \(.*\) do$/\1describe(\2) do/' \
                    >> "$TEMP_SPEC"
                echo "" >> "$TEMP_SPEC"
            fi
        fi
    done < "$SPEC_FILE"

    # Filter out require_relative lines and append the spec content
    # WORKAROUND: Add parentheses to describe/it_behaves_like calls to avoid compiler bug
    # Bug: calling func without parens when func has default param + &block causes segfault
    # WORKAROUND: Rewrite instance variables to global variables since instance_eval is not implemented
    # This allows 'before :each' blocks to work by using globals instead of instance vars
    cat "$SPEC_FILE" | grep -v "require_relative" | \
        sed 's/^\([[:space:]]*\)describe \(.*\) do$/\1describe(\2) do/' | \
        sed 's/^\([[:space:]]*\)it_behaves_like \(.*\)$/\1it_behaves_like(\2)/' | \
        sed 's/@\([a-zA-Z_][a-zA-Z0-9_]*\)/$spec_\1/g' \
        >> "$TEMP_SPEC"
    echo "end" >> "$TEMP_SPEC"
    echo "" >> "$TEMP_SPEC"
    echo "run_specs" >> "$TEMP_SPEC"
    echo "print_spec_results" >> "$TEMP_SPEC"

    echo "Compiling $SPEC_FILE..."
    COMPILE_OUTPUT=$(./compile "$TEMP_SPEC" -I. 2>&1)

    if [ $? -eq 0 ]; then
        echo "✓ Compilation successful"
        echo
        echo "Running spec..."
        echo "================================"
        TEMP_SPEC_NAME=$(basename "$TEMP_SPEC" .rb)
        ./out/${TEMP_SPEC_NAME}
        EXIT_CODE=$?
        # rm -f "$TEMP_SPEC"

        if [ $EXIT_CODE -eq 136 ] || [ $EXIT_CODE -eq 139 ]; then
            echo
            echo "✗ Segfault/Runtime error (exit code: $EXIT_CODE)"
            exit 2
        fi
        exit $EXIT_CODE
    else
        echo "✗ Compilation failed!"
        echo "================================"
        echo "$COMPILE_OUTPUT"
        # rm -f "$TEMP_SPEC"
        exit 3
    fi
else
    echo "Error: $TARGET is neither a file nor a directory"
    exit 1
fi
