
# See Symbol for a discussion of type tagging.
#
# FIXME: For (right) now String objects are sort-of immutable.
# At least #concat needs to be implemented for our needed
# use in #attr_writer.
class String
  # NOTE
  # Changing this to '= ""' is likely to fail, as it
  # gets translated into '__get_string("")', which
  # will do (callm String new), leading to a loop that
  # will only terminate when the stack blows up.
  #
  # Setting it "= <some other default>" may work, but
  # will be prone to order of bootstrapping the core
  # classes.
  #
  def initialize *str
    # @buffer contains the pointer to raw memory
    # used to contain the string.
    # 
    # An s-expression is used rather than = because
    # 0 outside of the s-expression eventually will
    # be an FixNum instance instead of the actual
    # value 0.

    %s(if (lt numargs 3)
         (assign @buffer "")
         (do 
            (assign len (callm (index str 0) length))
            (callm self __copy_raw ((callm (index str 0) __get_raw) len)))
        )
  end

  def is_a? c
    true
  end

  def nil?
    false
  end

  def [] index
    l = length
    if index < 0
      index = l + index
      if index < 0
        return nil
      end
    end

    if index >= l
      return nil
    end
    %s(assign index (callm index __get_raw))
    %s(assign c (bindex @buffer index))
    %s(__get_fixnum c)
  end

  def == other
    %s(assign res (if (strcmp @buffer (callm other __get_raw)) false true))
    return res
  end

  def __copy_raw(str,len)
    %s(assign len (callm len __get_raw))
    %s(assign @buffer (malloc len))
    %s(memmove @buffer str len)
   end

  def __set_raw(str)
    @buffer = str
  end

  def __get_raw
    @buffer
  end

  def empty?
    # FIXME: horribly inefficient while length is calculated with strlen...
    length == 0
  end

  def each_byte
  end

  def uniq
  end

  def to_s
    self
  end

  def to_sym
    buffer = @buffer
    %s(call __get_symbol buffer)
  end

  def to_i
  end

  def slice!(b,e)

    l = length
    # Negative offset?
    if b < 0
      b = l + b
    end
    
    if b < 0
      return nil
    end

    endp = b + e
    if endp > l
      e = l - b
    end

    n = String.new
    %s(assign src (add @buffer (callm b __get_raw)))
    n.__copy_raw(src, e)

    endp = b + e + 1
    %s(assign dest (add @buffer (callm b __get_raw)))
    %s(assign src (add @buffer (callm endp __get_raw)))
    %s(memmove dest src (callm e __get_raw))

    n
   end


  def reverse
  end

  def length
    # FIXME: yes, we should not assume C-strings
    # FIXME: Also, this is not nice if @buffer == -
    %s(assign l (strlen @buffer))
    %s(__get_fixnum l)
  end

  def count
  end

  # FIXME: This is horrible: Need to keep track of capacity separate from length,
  # and need to store length to be able to handle strings with \0 in the middle.
  def concat(other)
    other = other.to_s
    %s(do
         (assign ro (callm other __get_raw))
         (assign osize (strlen ro))
         (assign bsize (strlen @buffer))
         (assign size (add bsize osize))
         (assign size (add size 1))
         (assign newb (malloc size))
         (strcpy newb @buffer)
         (strcat newb ro)
         (assign @buffer newb)
   )
    self
  end
end

# FIXME: This is an interesting bootstrapping problem
# __get_string can only be called from an s-expression,
# since otherwise "str" will get rewritten to __get_string(str)
# if str is a string constant.
#
# It is still not a satisfactory solution: It ought to never
# be possible to call __set_raw or __get_string directly from
# "normal" Ruby code. Or at the very least a nasty warning
# should be generated. A solution for that might be a pragma
# like the one below (hypothetical, not implemented, indicating
# the call should only be allowed for code generated by the
# compiler)
#
# Another alternative is to implement
#
# pragma compiler-only
%s(defun __get_string (str) (let (s)
  (assign s (callm String new))
  (callm s __set_raw (str))
  s
))
